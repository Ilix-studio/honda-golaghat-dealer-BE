"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCustomerServiceStats = exports.getBookingStats = exports.getBranchUpcomingAppointments = exports.checkTimeSlotAvailability = exports.cancelServiceBooking = exports.updateBookingStatus = exports.getServiceBookingById = exports.getServiceBookings = exports.getCustomerBookings = exports.createServiceBooking = void 0;
const express_async_handler_1 = __importDefault(require("express-async-handler"));
const mongoose_1 = __importDefault(require("mongoose"));
const Branch_1 = __importDefault(require("../../models/Branch"));
const CustomerProfile_1 = require("../../models/CustomerSystem/CustomerProfile");
const user_types_1 = require("../../types/user.types");
const logger_1 = __importDefault(require("../../utils/logger"));
const ServiceBooking_1 = __importDefault(require("../../models/CustomerSystem/ServiceBooking"));
const CustomerVehicleModel_1 = require("../../models/BikeSystemModel2/CustomerVehicleModel");
const serviceBooking_types_1 = require("../../types/serviceBooking.types");
/**
 * @desc    Create a new service booking (authenticated customers only)
 * @route   POST /api/service-bookings
 * @access  Private (Customer)
 */
exports.createServiceBooking = (0, express_async_handler_1.default)(async (req, res) => {
    const { vehicle, // CustomerVehicle reference
    serviceType, // Single service only
    branch, // Branch reference
    appointmentDate, appointmentTime, location, // branch, home, office, roadside
    specialRequests, isDropOff, willWaitOnsite, termsAccepted, } = req.body;
    if (!req.customer) {
        res.status(401);
        throw new Error("Customer authentication required");
    }
    // Validate required fields
    if (!vehicle ||
        !serviceType ||
        !branch ||
        !appointmentDate ||
        !appointmentTime ||
        !location ||
        !termsAccepted) {
        res.status(400);
        throw new Error("Please provide all required fields");
    }
    // Validate service type exists in allowed services
    const allFreeServices = serviceBooking_types_1.FREE_SERVICES.map((s) => s.id);
    const allPaidServices = serviceBooking_types_1.PAID_SERVICES.map((s) => s.id);
    const allServices = [...allFreeServices, ...allPaidServices];
    if (!allServices.includes(serviceType)) {
        res.status(400);
        throw new Error(`Invalid service type: ${serviceType}. Please select a valid service.`);
    }
    // Check if customer has already used this service
    const hasUsedService = await ServiceBooking_1.default.hasCustomerUsedService(req.customer._id.toString(), serviceType);
    if (hasUsedService) {
        res.status(400);
        throw new Error("You have already used this service. Each service can only be booked once.");
    }
    // Validate vehicle belongs to customer
    if (!mongoose_1.default.Types.ObjectId.isValid(vehicle)) {
        res.status(400);
        throw new Error("Invalid vehicle ID");
    }
    const customerVehicle = await CustomerVehicleModel_1.CustomerVehicleModel.findOne({
        _id: vehicle,
        customer: req.customer._id,
        isActive: true,
    }).populate("stockConcept");
    if (!customerVehicle) {
        res.status(404);
        throw new Error("Vehicle not found or doesn't belong to customer");
    }
    // Validate branch exists
    if (!mongoose_1.default.Types.ObjectId.isValid(branch)) {
        res.status(400);
        throw new Error("Invalid branch ID");
    }
    const branchDoc = await Branch_1.default.findById(branch);
    if (!branchDoc) {
        res.status(404);
        throw new Error("Branch not found");
    }
    // Validate appointment date is in the future
    const appointmentDateTime = new Date(appointmentDate);
    if (appointmentDateTime <= new Date()) {
        res.status(400);
        throw new Error("Appointment date must be in the future");
    }
    // Validate appointment time format and extract minutes
    const timeMatch = appointmentTime.match(/^([0-1]?[0-9]|2[0-3]):([0-5][0-9])$/);
    if (!timeMatch) {
        res.status(400);
        throw new Error("Invalid time format. Use HH:MM format");
    }
    const appointmentMinutes = parseInt(timeMatch[1]) * 60 + parseInt(timeMatch[2]);
    // Check availability with 20-minute buffer
    const isAvailable = await ServiceBooking_1.default.checkAvailabilityWithBuffer(branch, appointmentDateTime, appointmentTime, 20 // 20-minute buffer
    );
    if (!isAvailable) {
        res.status(409);
        throw new Error("Time slot is not available. Please choose a time at least 20 minutes apart from existing bookings.");
    }
    // Create the service booking
    const serviceBooking = await ServiceBooking_1.default.create({
        customer: req.customer._id,
        vehicle,
        serviceType,
        usedServices: [serviceType], // Track this service as used
        branch,
        appointmentDate: appointmentDateTime,
        appointmentTime,
        location,
        specialRequests: specialRequests || undefined,
        serviceOptions: {
            isDropOff: isDropOff || false,
            willWaitOnsite: willWaitOnsite || false,
        },
        termsAccepted: true,
        termsAcceptedAt: new Date(),
    });
    // Send admin notification
    await serviceBooking.sendAdminNotification();
    // Populate related data for response
    await serviceBooking.populate([
        { path: "customer", select: "phoneNumber firebaseUid" },
        {
            path: "vehicle",
            populate: {
                path: "stockConcept",
                model: "StockConcept",
            },
        },
        { path: "branch", select: "name address phone email" },
    ]);
    // Manually get customer profile
    const customerProfile = await CustomerProfile_1.CustomerProfileModel.findOne({
        customer: req.customer._id,
    });
    const responseData = {
        ...serviceBooking.toObject(),
        customerProfile,
    };
    logger_1.default.info(`Service booking created: ${serviceBooking.bookingId} for customer ${req.customer._id}`);
    res.status(201).json({
        success: true,
        message: "Service booking created successfully",
        data: {
            bookingId: serviceBooking.bookingId,
            appointmentDateTime: serviceBooking.appointmentDateTime,
            branch: serviceBooking.branch,
            estimatedCost: serviceBooking.estimatedCost,
            serviceType: serviceBooking.serviceType,
            status: serviceBooking.status,
            customer: responseData.customer,
            customerProfile: responseData.customerProfile,
        },
    });
});
/**
 * @desc    Get customer's service bookings
 * @route   GET /api/service-bookings/my-bookings
 * @access  Private (Customer)
 */
exports.getCustomerBookings = (0, express_async_handler_1.default)(async (req, res) => {
    if (!req.customer) {
        res.status(401);
        throw new Error("Customer authentication required");
    }
    const { status, page = 1, limit = 10, sortBy = "appointmentDate", sortOrder = "desc", } = req.query;
    // Build query
    const query = { customer: req.customer._id };
    if (status) {
        query.status = status;
    }
    // Pagination
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    const skip = (pageNum - 1) * limitNum;
    // Sorting
    const sort = {};
    sort[sortBy] = sortOrder === "desc" ? -1 : 1;
    // Execute query
    const total = await ServiceBooking_1.default.countDocuments(query);
    const bookings = await ServiceBooking_1.default.find(query)
        .populate([
        {
            path: "vehicle",
            populate: {
                path: "stockConcept",
                model: "StockConcept",
            },
        },
        { path: "branch", select: "name address phone" },
    ])
        .sort(sort)
        .limit(limitNum)
        .skip(skip);
    res.status(200).json({
        success: true,
        count: bookings.length,
        total,
        totalPages: Math.ceil(total / limitNum),
        currentPage: pageNum,
        data: bookings,
    });
});
/**
 * @desc    Get all service bookings with filtering and pagination (Admin)
 * @route   GET /api/service-bookings
 * @access  Private (Admin only)
 */
exports.getServiceBookings = (0, express_async_handler_1.default)(async (req, res) => {
    const { status, branchId, startDate, endDate, serviceType, page = 1, limit = 10, sortBy = "appointmentDate", sortOrder = "asc", } = req.query;
    // Build query
    const query = {};
    // For Branch Managers, restrict to their branch only
    if (req.user && (0, user_types_1.isBranchManager)(req.user)) {
        const userBranch = (0, user_types_1.getUserBranch)(req.user);
        if (userBranch) {
            query.branch = userBranch;
        }
    }
    if (status) {
        query.status = status;
    }
    if (branchId) {
        if (!mongoose_1.default.Types.ObjectId.isValid(branchId)) {
            res.status(400);
            throw new Error("Invalid branch ID");
        }
        // Check if user can access this branch
        if (req.user && !(0, user_types_1.canAccessBranch)(req.user, branchId)) {
            res.status(403);
            throw new Error("Access denied to this branch");
        }
        query.branch = branchId;
    }
    if (serviceType) {
        query.serviceType = serviceType;
    }
    // Date range filter
    if (startDate || endDate) {
        query.appointmentDate = {};
        if (startDate) {
            query.appointmentDate.$gte = new Date(startDate);
        }
        if (endDate) {
            query.appointmentDate.$lte = new Date(endDate);
        }
    }
    // Pagination
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    const skip = (pageNum - 1) * limitNum;
    // Sorting
    const sort = {};
    sort[sortBy] = sortOrder === "desc" ? -1 : 1;
    // Execute query
    const total = await ServiceBooking_1.default.countDocuments(query);
    const bookings = await ServiceBooking_1.default.find(query)
        .populate([
        { path: "customer", select: "phoneNumber firebaseUid" },
        {
            path: "vehicle",
            populate: {
                path: "stockConcept",
                model: "StockConcept",
            },
        },
        { path: "branch", select: "name address phone" },
    ])
        .sort(sort)
        .limit(limitNum)
        .skip(skip);
    res.status(200).json({
        success: true,
        count: bookings.length,
        total,
        totalPages: Math.ceil(total / limitNum),
        currentPage: pageNum,
        data: bookings,
    });
});
/**
 * @desc    Get a single service booking by ID
 * @route   GET /api/service-bookings/:id
 * @access  Private (Customer for own bookings, Admin for all)
 */
exports.getServiceBookingById = (0, express_async_handler_1.default)(async (req, res) => {
    const { id } = req.params;
    let booking;
    // Check if it's a MongoDB ObjectId or booking ID
    if (mongoose_1.default.Types.ObjectId.isValid(id)) {
        booking = await ServiceBooking_1.default.findById(id);
    }
    else {
        // Search by booking ID (e.g., SB-20241201-0001)
        booking = await ServiceBooking_1.default.findOne({ bookingId: id });
    }
    if (!booking) {
        res.status(404);
        throw new Error("Service booking not found");
    }
    // Check access permissions
    if (req.customer) {
        // Customer can only access their own bookings
        if (booking.customer.toString() !== req.customer._id.toString()) {
            res.status(403);
            throw new Error("Access denied to this booking");
        }
    }
    else if (req.user) {
        // Admin access control
        if ((0, user_types_1.isBranchManager)(req.user)) {
            const userBranch = (0, user_types_1.getUserBranch)(req.user);
            if (userBranch && booking.branch.toString() !== userBranch.toString()) {
                res.status(403);
                throw new Error("Access denied to this booking");
            }
        }
    }
    else {
        res.status(401);
        throw new Error("Authentication required");
    }
    // Populate related data
    await booking.populate([
        { path: "customer", select: "phoneNumber firebaseUid" },
        {
            path: "vehicle",
            populate: {
                path: "stockConcept",
                model: "StockConcept",
            },
        },
        { path: "branch", select: "name address phone email hours" },
    ]);
    res.status(200).json({
        success: true,
        data: booking,
    });
});
/**
 * @desc    Update service booking status
 * @route   PATCH /api/service-bookings/:id/status
 * @access  Private (Admin only)
 */
exports.updateBookingStatus = (0, express_async_handler_1.default)(async (req, res) => {
    const { id } = req.params;
    const { status, assignedTechnician, serviceNotes, estimatedCost, actualCost, estimatedDuration, } = req.body;
    if (!mongoose_1.default.Types.ObjectId.isValid(id)) {
        res.status(400);
        throw new Error("Invalid booking ID");
    }
    const booking = await ServiceBooking_1.default.findById(id);
    if (!booking) {
        res.status(404);
        throw new Error("Service booking not found");
    }
    // Check access permissions
    if (req.user && (0, user_types_1.isBranchManager)(req.user)) {
        const userBranch = (0, user_types_1.getUserBranch)(req.user);
        if (userBranch && booking.branch.toString() !== userBranch.toString()) {
            res.status(403);
            throw new Error("Access denied to this booking");
        }
    }
    // Validate status transition
    const validStatuses = [
        "pending",
        "confirmed",
        "in-progress",
        "completed",
        "cancelled",
    ];
    if (status && !validStatuses.includes(status)) {
        res.status(400);
        throw new Error("Invalid status");
    }
    // Update fields
    if (status)
        booking.status = status;
    if (assignedTechnician)
        booking.assignedTechnician = assignedTechnician;
    if (serviceNotes)
        booking.serviceNotes = serviceNotes;
    if (estimatedCost)
        booking.estimatedCost = estimatedCost;
    if (actualCost)
        booking.actualCost = actualCost;
    if (estimatedDuration)
        booking.estimatedDuration = estimatedDuration;
    await booking.save();
    const userRole = req.user ? (0, user_types_1.getUserRole)(req.user) : "system";
    logger_1.default.info(`Service booking ${booking.bookingId} status updated to ${status} by ${userRole}`);
    res.status(200).json({
        success: true,
        message: "Booking status updated successfully",
        data: {
            bookingId: booking.bookingId,
            status: booking.status,
            updatedAt: booking.updatedAt,
        },
    });
});
/**
 * @desc    Cancel a service booking
 * @route   DELETE /api/service-bookings/:id/cancel
 * @access  Private (Customer for own bookings, Admin for all)
 */
exports.cancelServiceBooking = (0, express_async_handler_1.default)(async (req, res) => {
    const { id } = req.params;
    const { reason } = req.body;
    let booking;
    // Find booking by ID or booking ID
    if (mongoose_1.default.Types.ObjectId.isValid(id)) {
        booking = await ServiceBooking_1.default.findById(id);
    }
    else {
        booking = await ServiceBooking_1.default.findOne({ bookingId: id });
    }
    if (!booking) {
        res.status(404);
        throw new Error("Service booking not found");
    }
    // Check access permissions
    if (req.customer) {
        // Customer can only cancel their own bookings
        if (booking.customer.toString() !== req.customer._id.toString()) {
            res.status(403);
            throw new Error("Access denied to this booking");
        }
    }
    else if (req.user) {
        // Admin access control
        if ((0, user_types_1.isBranchManager)(req.user)) {
            const userBranch = (0, user_types_1.getUserBranch)(req.user);
            if (userBranch && booking.branch.toString() !== userBranch.toString()) {
                res.status(403);
                throw new Error("Access denied to this booking");
            }
        }
    }
    else {
        res.status(401);
        throw new Error("Authentication required");
    }
    // Check if booking can be cancelled
    if (booking.status === "completed") {
        res.status(400);
        throw new Error("Cannot cancel a completed booking");
    }
    if (booking.status === "cancelled") {
        res.status(400);
        throw new Error("Booking is already cancelled");
    }
    // Cancel the booking using the instance method
    await booking.cancelBooking(reason);
    logger_1.default.info(`Service booking ${booking.bookingId} cancelled. Reason: ${reason || "Not specified"}`);
    res.status(200).json({
        success: true,
        message: "Service booking cancelled successfully",
        data: {
            bookingId: booking.bookingId,
            status: booking.status,
            cancelledAt: booking.updatedAt,
        },
    });
});
/**
 * @desc    Check time slot availability
 * @route   GET /api/service-bookings/availability
 * @access  Private (Customer)
 */
exports.checkTimeSlotAvailability = (0, express_async_handler_1.default)(async (req, res) => {
    const { branchId, date } = req.query;
    if (!req.customer) {
        res.status(401);
        throw new Error("Customer authentication required");
    }
    if (!branchId || !date) {
        res.status(400);
        throw new Error("Branch ID and date are required");
    }
    if (!mongoose_1.default.Types.ObjectId.isValid(branchId)) {
        res.status(400);
        throw new Error("Invalid branch ID");
    }
    const appointmentDate = new Date(date);
    if (appointmentDate <= new Date()) {
        res.status(400);
        throw new Error("Date must be in the future");
    }
    // Get available time slots using static method
    const availableSlots = await ServiceBooking_1.default.getAvailableTimeSlots(branchId, appointmentDate);
    res.status(200).json({
        success: true,
        data: {
            date: appointmentDate.toDateString(),
            availableSlots,
            totalAvailable: availableSlots.length,
        },
    });
});
/**
 * @desc    Get upcoming appointments for a branch
 * @route   GET /api/service-bookings/branch/:branchId/upcoming
 * @access  Private (Branch Admin or Super Admin)
 */
exports.getBranchUpcomingAppointments = (0, express_async_handler_1.default)(async (req, res) => {
    const { branchId } = req.params;
    const { days = 7 } = req.query;
    if (!mongoose_1.default.Types.ObjectId.isValid(branchId)) {
        res.status(400);
        throw new Error("Invalid branch ID");
    }
    // Check access permissions
    if (req.user && !(0, user_types_1.canAccessBranch)(req.user, branchId)) {
        res.status(403);
        throw new Error("Access denied to this branch data");
    }
    const today = new Date();
    const futureDate = new Date();
    futureDate.setDate(today.getDate() + parseInt(days));
    const appointments = await ServiceBooking_1.default.find({
        branch: branchId,
        appointmentDate: {
            $gte: today,
            $lte: futureDate,
        },
        status: { $in: ["pending", "confirmed", "in-progress"] },
    })
        .populate([
        { path: "customer", select: "phoneNumber firebaseUid" },
        {
            path: "vehicle",
            populate: {
                path: "stockConcept",
                model: "StockConcept",
            },
        },
        { path: "branch", select: "name" },
    ])
        .sort({ appointmentDate: 1, appointmentTime: 1 });
    res.status(200).json({
        success: true,
        count: appointments.length,
        data: appointments,
    });
});
/**
 * @desc    Get booking statistics for dashboard
 * @route   GET /api/service-bookings/stats
 * @access  Private (Admin only)
 */
exports.getBookingStats = (0, express_async_handler_1.default)(async (req, res) => {
    const { branchId, startDate, endDate } = req.query;
    // Build base query
    const baseQuery = {};
    // For Branch Managers, restrict to their branch
    if (req.user && (0, user_types_1.isBranchManager)(req.user)) {
        const userBranch = (0, user_types_1.getUserBranch)(req.user);
        if (userBranch) {
            baseQuery.branch = userBranch;
        }
    }
    else if (branchId) {
        // For Super Admins, allow filtering by branch
        if (!mongoose_1.default.Types.ObjectId.isValid(branchId)) {
            res.status(400);
            throw new Error("Invalid branch ID");
        }
        baseQuery.branch = branchId;
    }
    // Date range filter
    if (startDate || endDate) {
        baseQuery.createdAt = {};
        if (startDate) {
            baseQuery.createdAt.$gte = new Date(startDate);
        }
        if (endDate) {
            baseQuery.createdAt.$lte = new Date(endDate);
        }
    }
    // Get various statistics
    const [totalBookings, statusStats, serviceTypeStats, revenueStats, monthlyTrend, notificationStats,] = await Promise.all([
        // Total bookings
        ServiceBooking_1.default.countDocuments(baseQuery),
        // Bookings by status
        ServiceBooking_1.default.aggregate([
            { $match: baseQuery },
            { $group: { _id: "$status", count: { $sum: 1 } } },
        ]),
        // Bookings by service type
        ServiceBooking_1.default.aggregate([
            { $match: baseQuery },
            { $group: { _id: "$serviceType", count: { $sum: 1 } } },
        ]),
        // Revenue statistics
        ServiceBooking_1.default.aggregate([
            { $match: { ...baseQuery, actualCost: { $exists: true } } },
            {
                $group: {
                    _id: null,
                    totalRevenue: { $sum: "$actualCost" },
                    averageBookingValue: { $avg: "$actualCost" },
                    completedBookings: { $sum: 1 },
                },
            },
        ]),
        // Monthly trend
        ServiceBooking_1.default.aggregate([
            { $match: baseQuery },
            {
                $group: {
                    _id: {
                        year: { $year: "$createdAt" },
                        month: { $month: "$createdAt" },
                    },
                    count: { $sum: 1 },
                    revenue: { $sum: { $ifNull: ["$actualCost", 0] } },
                },
            },
            { $sort: { "_id.year": 1, "_id.month": 1 } },
        ]),
        // Notification statistics
        ServiceBooking_1.default.aggregate([
            { $match: baseQuery },
            {
                $group: {
                    _id: null,
                    totalNotificationsSent: {
                        $sum: { $cond: ["$adminNotificationSent", 1, 0] },
                    },
                    pendingNotifications: {
                        $sum: { $cond: ["$adminNotificationSent", 0, 1] },
                    },
                },
            },
        ]),
    ]);
    res.status(200).json({
        success: true,
        data: {
            totalBookings,
            statusDistribution: statusStats,
            serviceTypeDistribution: serviceTypeStats,
            revenue: revenueStats[0] || {
                totalRevenue: 0,
                averageBookingValue: 0,
                completedBookings: 0,
            },
            monthlyTrend,
            notifications: notificationStats[0] || {
                totalNotificationsSent: 0,
                pendingNotifications: 0,
            },
        },
    });
});
/**
 * @desc    Get customer service statistics
 * @route   GET /api/service-bookings/my-stats
 * @access  Private (Customer)
 */
exports.getCustomerServiceStats = (0, express_async_handler_1.default)(async (req, res) => {
    if (!req.customer) {
        res.status(401);
        throw new Error("Customer authentication required");
    }
    // Get total services used
    const totalServicesUsed = await ServiceBooking_1.default.getCustomerServiceCount(req.customer._id.toString());
    // Get used services list
    const usedServices = await ServiceBooking_1.default.find({
        customer: req.customer._id,
        status: { $in: ["confirmed", "completed"] },
    }).select("serviceType");
    const usedServiceTypes = usedServices.map((booking) => booking.serviceType);
    // Calculate available services
    const allFreeServices = serviceBooking_types_1.FREE_SERVICES.map((s) => s.id);
    const allPaidServices = serviceBooking_types_1.PAID_SERVICES.map((s) => s.id);
    const allServices = [...allFreeServices, ...allPaidServices];
    const availableServices = allServices.filter((service) => !usedServiceTypes.includes(service));
    res.status(200).json({
        success: true,
        data: {
            totalServicesUsed,
            availableServicesCount: availableServices.length,
            usedServicesCount: usedServiceTypes.length,
            usedServiceTypes,
            availableServices,
            breakdown: {
                freeServicesUsed: usedServiceTypes.filter((s) => allFreeServices.includes(s)).length,
                paidServicesUsed: usedServiceTypes.filter((s) => allPaidServices.includes(s)).length,
            },
        },
    });
});
